import { BaseRepository, PaginatedResult } from './BaseRepository';
import { PoolClient } from 'pg';
import { logger } from '../utils/logger';

export interface TransactionMetadata {
  manual?: boolean;
  adminAddress?: string;
  reason?: string;
  previousBalance?: number;
  source?: string;
  bulk?: boolean;
  campaign?: boolean;
  repairAmount?: number;
  referralId?: string;
  engagementType?: string;
  redemptionLocation?: string;
  webhookId?: string;
  burnSuccessful?: boolean;
  sessionId?: string;
  autoProcessed?: boolean;
  amountFromBlockchain?: number;
  amountFromDatabase?: number;
  redemptionStrategy?: string;
  originalRequestAmount?: number;
  requestedAt?: string;
  rejectedAt?: string;
  cancelledAt?: string;
  rejectedByCustomer?: boolean;
  cancelledByShop?: boolean;
  // Cross-shop verification specific fields
  verificationType?: string;
  originalShopId?: string;
  redemptionShopId?: string;
  availableBalance?: number;
  maxCrossShopAmount?: number;
  denialReason?: string;
  verificationId?: string;
  // Tier bonus specific fields
  customerTier?: 'BRONZE' | 'SILVER' | 'GOLD';
  baseTransactionId?: string;
  [key: string]: unknown; // Allow additional properties while maintaining type safety
}

export interface TransactionRecord {
  id?: string; // Optional since it's auto-generated by database
  type: 'mint' | 'redeem' | 'transfer' | 'transfer_in' | 'transfer_out' | 'tier_bonus' | 'shop_purchase' | 'rejected_redemption' | 'cancelled_redemption' | 'cross_shop_verification' | 'service_redemption' | 'service_redemption_refund';
  customerAddress: string;
  shopId?: string;
  amount: number;
  reason?: string;
  transactionHash?: string;
  blockNumber?: number;
  timestamp: string;
  status: 'pending' | 'confirmed' | 'failed' | 'completed';
  metadata?: TransactionMetadata;
  shopName?: string;
  customerName?: string;
  createdAt?: Date;
}

export interface TransactionFilters {
  customerAddress?: string;
  shopId?: string;
  type?: 'mint' | 'redeem' | 'transfer' | 'tier_bonus' | 'shop_purchase';
  status?: 'pending' | 'confirmed' | 'failed';
  startDate?: string;
  endDate?: string;
}

export class TransactionRepository extends BaseRepository {
  /**
   * Record a transaction - supports optional PoolClient for atomic transactions
   * @param transaction The transaction record to insert
   * @param client Optional PoolClient for transaction support
   */
  async recordTransaction(transaction: TransactionRecord, client?: PoolClient): Promise<void> {
    try {
      const query = `
        INSERT INTO transactions (
          type, customer_address, shop_id, amount, reason,
          transaction_hash, block_number, timestamp, status, metadata
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
      `;

      const values = [
        transaction.type,
        transaction.customerAddress.toLowerCase(),
        transaction.shopId,
        transaction.amount,
        transaction.reason,
        transaction.transactionHash,
        transaction.blockNumber,
        transaction.timestamp,
        transaction.status,
        JSON.stringify(transaction.metadata || {})
      ];

      // Use provided client for transaction support, or fall back to pool
      if (client) {
        await client.query(query, values);
      } else {
        await this.pool.query(query, values);
      }

      logger.info('Transaction recorded', {
        id: transaction.id,
        type: transaction.type,
        amount: transaction.amount
      });
    } catch (error) {
      logger.error('Error recording transaction:', error);
      throw new Error('Failed to record transaction');
    }
  }

  async getTransaction(id: string): Promise<TransactionRecord | null> {
    try {
      const query = 'SELECT * FROM transactions WHERE id = $1';
      const result = await this.pool.query(query, [id]);
      
      if (result.rows.length === 0) {
        return null;
      }
      
      return this.mapToTransactionRecord(result.rows[0]);
    } catch (error) {
      logger.error('Error fetching transaction:', error);
      throw new Error('Failed to fetch transaction');
    }
  }

  async getTransactionsByCustomer(
    customerAddress: string,
    limit: number = 50,
    offset: number = 0
  ): Promise<TransactionRecord[]> {
    try {
      const query = `
        SELECT t.*, s.name as shop_name 
        FROM transactions t
        LEFT JOIN shops s ON t.shop_id = s.shop_id
        WHERE t.customer_address = $1
        ORDER BY t.timestamp DESC
        LIMIT $2 OFFSET $3
      `;
      
      const result = await this.pool.query(query, [
        customerAddress.toLowerCase(),
        limit,
        offset
      ]);
      
      return result.rows.map(row => this.mapToTransactionRecord(row));
    } catch (error) {
      logger.error('Error fetching customer transactions:', error);
      throw new Error('Failed to fetch customer transactions');
    }
  }

  /**
   * Get aggregated transaction totals for a customer in a single efficient query
   * This replaces the inefficient pattern of fetching 1000 rows and looping in JS
   */
  async getCustomerTransactionTotals(customerAddress: string): Promise<{
    totalRedeemed: number;
    totalMintedToWallet: number;
    totalEarned: number;
  }> {
    try {
      const query = `
        SELECT
          COALESCE(SUM(CASE WHEN type = 'redeem' THEN amount ELSE 0 END), 0) as total_redeemed,
          COALESCE(SUM(CASE WHEN type = 'mint' AND (
            metadata->>'mintType' = 'instant_mint' OR
            metadata->>'source' = 'customer_dashboard'
          ) THEN amount ELSE 0 END), 0) as total_minted_to_wallet,
          COALESCE(SUM(CASE WHEN type IN ('earn', 'reward', 'referral_bonus', 'tier_bonus') THEN amount ELSE 0 END), 0) as total_earned
        FROM transactions
        WHERE customer_address = $1
      `;

      const result = await this.pool.query(query, [customerAddress.toLowerCase()]);

      return {
        totalRedeemed: parseFloat(result.rows[0]?.total_redeemed || 0),
        totalMintedToWallet: parseFloat(result.rows[0]?.total_minted_to_wallet || 0),
        totalEarned: parseFloat(result.rows[0]?.total_earned || 0)
      };
    } catch (error) {
      logger.error('Error getting customer transaction totals:', error);
      throw new Error('Failed to get customer transaction totals');
    }
  }

  async getTransactionsByShop(
    shopId: string,
    limit: number = 50,
    offset: number = 0
  ): Promise<TransactionRecord[]> {
    try {
      const query = `
        SELECT t.*, c.name as customer_name 
        FROM transactions t
        LEFT JOIN customers c ON t.customer_address = c.address
        WHERE t.shop_id = $1
        ORDER BY t.timestamp DESC
        LIMIT $2 OFFSET $3
      `;
      
      const result = await this.pool.query(query, [shopId, limit, offset]);
      
      return result.rows.map(row => this.mapToTransactionRecord(row));
    } catch (error) {
      logger.error('Error fetching shop transactions:', error);
      throw new Error('Failed to fetch shop transactions');
    }
  }

  async getTransactionsPaginated(
    filters: TransactionFilters & { page: number; limit: number }
  ): Promise<PaginatedResult<TransactionRecord>> {
    try {
      let whereClause = 'WHERE 1=1';
      const params: any[] = [];
      let paramCount = 0;

      if (filters.customerAddress) {
        paramCount++;
        whereClause += ` AND t.customer_address = $${paramCount}`;
        params.push(filters.customerAddress.toLowerCase());
      }

      if (filters.shopId) {
        paramCount++;
        whereClause += ` AND t.shop_id = $${paramCount}`;
        params.push(filters.shopId);
      }

      if (filters.type) {
        paramCount++;
        whereClause += ` AND t.type = $${paramCount}`;
        params.push(filters.type);
      }

      if (filters.status) {
        paramCount++;
        whereClause += ` AND t.status = $${paramCount}`;
        params.push(filters.status);
      }

      if (filters.startDate) {
        paramCount++;
        whereClause += ` AND t.timestamp >= $${paramCount}`;
        params.push(filters.startDate);
      }

      if (filters.endDate) {
        paramCount++;
        whereClause += ` AND t.timestamp <= $${paramCount}`;
        params.push(filters.endDate);
      }

      // Get total count
      const countQuery = `SELECT COUNT(*) FROM transactions t ${whereClause}`;
      const countResult = await this.pool.query(countQuery, params);
      const totalItems = parseInt(countResult.rows[0].count);

      // Get paginated results
      const offset = this.getPaginationOffset(filters.page, filters.limit);
      paramCount++;
      params.push(filters.limit);
      paramCount++;
      params.push(offset);

      const query = `
        SELECT t.*, s.name as shop_name, c.name as customer_name
        FROM transactions t
        LEFT JOIN shops s ON t.shop_id = s.shop_id
        LEFT JOIN customers c ON t.customer_address = c.address
        ${whereClause}
        ORDER BY t.timestamp DESC
        LIMIT $${paramCount - 1} OFFSET $${paramCount}
      `;

      const result = await this.pool.query(query, params);
      
      const transactions = result.rows.map(row => this.mapToTransactionRecord(row));
      const totalPages = Math.ceil(totalItems / filters.limit);

      return {
        items: transactions,
        pagination: {
          page: filters.page,
          limit: filters.limit,
          totalItems,
          totalPages,
          hasMore: filters.page < totalPages
        }
      };
    } catch (error) {
      logger.error('Error getting paginated transactions:', error);
      throw new Error('Failed to get transactions');
    }
  }

  async getByTransactionHash(transactionHash: string): Promise<TransactionRecord | null> {
    try {
      const query = 'SELECT * FROM transactions WHERE transaction_hash = $1';
      const result = await this.pool.query(query, [transactionHash]);
      
      if (result.rows.length === 0) {
        return null;
      }
      
      return this.mapToTransactionRecord(result.rows[0]);
    } catch (error) {
      logger.error('Error fetching transaction by hash:', error);
      throw new Error('Failed to fetch transaction by hash');
    }
  }

  async create(transaction: Omit<TransactionRecord, 'id' | 'createdAt'>): Promise<TransactionRecord> {
    try {
      const query = `
        INSERT INTO transactions (
          type, customer_address, shop_id, amount, reason,
          transaction_hash, block_number, timestamp, status, metadata
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        RETURNING *
      `;
      
      const result = await this.pool.query(query, [
        transaction.type,
        transaction.customerAddress.toLowerCase(),
        transaction.shopId,
        transaction.amount,
        transaction.reason,
        transaction.transactionHash,
        transaction.blockNumber,
        transaction.timestamp,
        transaction.status,
        JSON.stringify(transaction.metadata || {})
      ]);
      
      const createdTransaction = this.mapToTransactionRecord(result.rows[0]);
      logger.info('Transaction created', { 
        id: createdTransaction.id, 
        type: createdTransaction.type,
        amount: createdTransaction.amount 
      });
      
      return createdTransaction;
    } catch (error) {
      logger.error('Error creating transaction:', error);
      throw new Error('Failed to create transaction');
    }
  }

  async getTransferHistory(
    customerAddress: string,
    limit: number = 50,
    offset: number = 0
  ): Promise<TransactionRecord[]> {
    try {
      const query = `
        SELECT * FROM transactions
        WHERE customer_address = $1 
        AND type IN ('transfer_in', 'transfer_out')
        ORDER BY timestamp DESC
        LIMIT $2 OFFSET $3
      `;
      
      const result = await this.pool.query(query, [
        customerAddress.toLowerCase(),
        limit,
        offset
      ]);
      
      return result.rows.map(row => this.mapToTransactionRecord(row));
    } catch (error) {
      logger.error('Error fetching transfer history:', error);
      throw new Error('Failed to fetch transfer history');
    }
  }

  async getTransferHistoryCount(customerAddress: string): Promise<number> {
    try {
      const query = `
        SELECT COUNT(*) as count FROM transactions
        WHERE customer_address = $1 
        AND type IN ('transfer_in', 'transfer_out')
      `;
      
      const result = await this.pool.query(query, [customerAddress.toLowerCase()]);
      return parseInt(result.rows[0].count);
    } catch (error) {
      logger.error('Error getting transfer history count:', error);
      throw new Error('Failed to get transfer history count');
    }
  }

  async updateTransactionStatus(
    id: string, 
    status: 'pending' | 'confirmed' | 'failed' | 'completed',
    blockNumber?: number
  ): Promise<void> {
    try {
      let query = `
        UPDATE transactions 
        SET status = $1, updated_at = NOW()
      `;
      const params: any[] = [status];
      let paramCount = 1;

      if (blockNumber !== undefined) {
        paramCount++;
        query += `, block_number = $${paramCount}`;
        params.push(blockNumber);
      }

      paramCount++;
      query += ` WHERE id = $${paramCount}`;
      params.push(id);

      await this.pool.query(query, params);
      logger.info('Transaction status updated', { id, status });
    } catch (error) {
      logger.error('Error updating transaction status:', error);
      throw new Error('Failed to update transaction status');
    }
  }

  async getRecentTransactions(
    limit: number = 10
  ): Promise<TransactionRecord[]> {
    try {
      const query = `
        SELECT t.*, s.name as shop_name, c.name as customer_name
        FROM transactions t
        LEFT JOIN shops s ON t.shop_id = s.shop_id
        LEFT JOIN customers c ON t.customer_address = c.address
        WHERE t.status = 'confirmed'
        ORDER BY t.timestamp DESC
        LIMIT $1
      `;
      
      const result = await this.pool.query(query, [limit]);
      
      return result.rows.map(row => this.mapToTransactionRecord(row));
    } catch (error) {
      logger.error('Error fetching recent transactions:', error);
      throw new Error('Failed to fetch recent transactions');
    }
  }

  async getTransactionStats(
    startDate?: string,
    endDate?: string
  ): Promise<{
    totalTransactions: number;
    totalMinted: number;
    totalRedeemed: number;
    totalVolume: number;
  }> {
    try {
      let whereClause = "WHERE status = 'confirmed'";
      const params: any[] = [];
      let paramCount = 0;

      if (startDate) {
        paramCount++;
        whereClause += ` AND timestamp >= $${paramCount}`;
        params.push(startDate);
      }

      if (endDate) {
        paramCount++;
        whereClause += ` AND timestamp <= $${paramCount}`;
        params.push(endDate);
      }

      const query = `
        SELECT 
          COUNT(*) as total_transactions,
          COALESCE(SUM(CASE WHEN type = 'mint' THEN amount ELSE 0 END), 0) as total_minted,
          COALESCE(SUM(CASE WHEN type = 'redeem' THEN amount ELSE 0 END), 0) as total_redeemed,
          COALESCE(SUM(amount), 0) as total_volume
        FROM transactions
        ${whereClause}
      `;
      
      const result = await this.pool.query(query, params);
      const row = result.rows[0];
      
      return {
        totalTransactions: parseInt(row.total_transactions),
        totalMinted: parseFloat(row.total_minted),
        totalRedeemed: parseFloat(row.total_redeemed),
        totalVolume: parseFloat(row.total_volume)
      };
    } catch (error) {
      logger.error('Error getting transaction stats:', error);
      throw new Error('Failed to get transaction stats');
    }
  }

  async getShopTransactions(
    shopId: string,
    filters: {
      page: number;
      limit: number;
      type?: string;
      startDate?: string;
      endDate?: string;
    }
  ): Promise<{
    items: any[];
    pagination: {
      page: number;
      limit: number;
      totalItems: number;
      totalPages: number;
      hasMore: boolean;
    };
  }> {
    try {
      const offset = (filters.page - 1) * filters.limit;
      let whereClause = 'WHERE t.shop_id = $1';
      const params: any[] = [shopId];
      let paramCount = 1;

      // Add type filter if provided
      if (filters.type) {
        if (filters.type === 'rewards') {
          whereClause += ` AND t.type = 'mint'`;
        } else if (filters.type === 'redemptions') {
          // Filter by type='redeem' OR by reason starting with 'Redemption'
          // This handles both new transactions with proper type and legacy transactions
          whereClause += ` AND (t.type = 'redeem' OR t.reason ILIKE 'Redemption%')`;
        } else if (filters.type === 'failed') {
          whereClause += ` AND t.status = 'failed'`;
        }
      }

      // Add date filters if provided
      if (filters.startDate) {
        paramCount++;
        whereClause += ` AND t.timestamp >= $${paramCount}`;
        params.push(filters.startDate);
      }

      if (filters.endDate) {
        paramCount++;
        whereClause += ` AND t.timestamp <= $${paramCount}`;
        params.push(filters.endDate);
      }

      // Get total count
      const countQuery = `
        SELECT COUNT(*) 
        FROM transactions t
        ${whereClause}
      `;
      const countResult = await this.pool.query(countQuery, params);
      const totalItems = parseInt(countResult.rows[0].count);

      // Get paginated results
      const query = `
        SELECT 
          t.*,
          c.name as customer_name
        FROM transactions t
        LEFT JOIN customers c ON t.customer_address = c.address
        ${whereClause}
        ORDER BY t.timestamp DESC
        LIMIT $${paramCount + 1} OFFSET $${paramCount + 2}
      `;
      params.push(filters.limit, offset);
      
      const result = await this.pool.query(query, params);
      const totalPages = Math.ceil(totalItems / filters.limit);

      return {
        items: result.rows,
        pagination: {
          page: filters.page,
          limit: filters.limit,
          totalItems,
          totalPages,
          hasMore: filters.page < totalPages
        }
      };
    } catch (error) {
      logger.error('Error getting shop transactions:', error);
      throw new Error('Failed to get shop transactions');
    }
  }

  async getTransactionsByType(customerAddress: string, type: string): Promise<TransactionRecord[]> {
    try {
      const query = `
        SELECT * FROM transactions 
        WHERE customer_address = $1 AND type = $2
        ORDER BY created_at DESC
      `;
      
      const result = await this.pool.query(query, [customerAddress.toLowerCase(), type]);
      return result.rows.map(row => this.mapToTransactionRecord(row));
    } catch (error) {
      logger.error('Error getting transactions by type:', error);
      throw new Error('Failed to get transactions by type');
    }
  }

  async getTransactionsByShopAndType(shopId: string, type: string): Promise<TransactionRecord[]> {
    try {
      const query = `
        SELECT * FROM transactions 
        WHERE shop_id = $1 AND type = $2
        ORDER BY created_at DESC
      `;
      
      const result = await this.pool.query(query, [shopId, type]);
      return result.rows.map(row => this.mapToTransactionRecord(row));
    } catch (error) {
      logger.error('Error getting transactions by shop and type:', error);
      throw new Error('Failed to get transactions by shop and type');
    }
  }

  private mapToTransactionRecord(row: any): TransactionRecord {
    return {
      id: row.id,
      type: row.type,
      customerAddress: row.customer_address,
      shopId: row.shop_id,
      amount: parseFloat(row.amount),
      reason: row.reason,
      transactionHash: row.transaction_hash,
      blockNumber: row.block_number,
      timestamp: row.timestamp,
      status: row.status,
      metadata: row.metadata,
      createdAt: row.created_at,
      // Additional fields from joins
      ...(row.shop_name && { shopName: row.shop_name }),
      ...(row.customer_name && { customerName: row.customer_name })
    };
  }

  // Public query method for custom queries
  async query(sql: string, params?: any[]) {
    return this.pool.query(sql, params);
  }

  /**
   * Create a pending transaction to record intent BEFORE blockchain operations.
   * This enables recovery if database fails after blockchain burn.
   * @param transaction The transaction record with status='pending'
   * @param client Optional PoolClient for transaction support
   * @returns The created transaction with its database ID
   */
  async createPendingTransaction(
    transaction: Omit<TransactionRecord, 'id' | 'createdAt'>,
    client?: PoolClient
  ): Promise<TransactionRecord> {
    try {
      const query = `
        INSERT INTO transactions (
          type, customer_address, shop_id, amount, reason,
          transaction_hash, block_number, timestamp, status, metadata
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        RETURNING *
      `;

      const values = [
        transaction.type,
        transaction.customerAddress.toLowerCase(),
        transaction.shopId,
        transaction.amount,
        transaction.reason,
        transaction.transactionHash || null,
        transaction.blockNumber || null,
        transaction.timestamp,
        'pending', // Always start as pending
        JSON.stringify(transaction.metadata || {})
      ];

      const result = client
        ? await client.query(query, values)
        : await this.pool.query(query, values);

      const createdTransaction = this.mapToTransactionRecord(result.rows[0]);
      logger.info('Pending transaction created', {
        id: createdTransaction.id,
        type: createdTransaction.type,
        amount: createdTransaction.amount
      });

      return createdTransaction;
    } catch (error) {
      logger.error('Error creating pending transaction:', error);
      throw new Error('Failed to create pending transaction');
    }
  }

  /**
   * Confirm a pending transaction after blockchain operation succeeds.
   * @param id The transaction ID to confirm
   * @param updates Additional fields to update (e.g., transactionHash)
   * @param client Optional PoolClient for transaction support
   */
  async confirmTransaction(
    id: string | number,
    updates: {
      transactionHash?: string;
      blockNumber?: number;
      metadata?: TransactionMetadata;
    },
    client?: PoolClient
  ): Promise<void> {
    try {
      let query = `
        UPDATE transactions
        SET status = 'confirmed', updated_at = NOW()
      `;
      const params: any[] = [];
      let paramCount = 0;

      if (updates.transactionHash) {
        paramCount++;
        query += `, transaction_hash = $${paramCount}`;
        params.push(updates.transactionHash);
      }

      if (updates.blockNumber !== undefined) {
        paramCount++;
        query += `, block_number = $${paramCount}`;
        params.push(updates.blockNumber);
      }

      if (updates.metadata) {
        paramCount++;
        query += `, metadata = metadata || $${paramCount}::jsonb`;
        params.push(JSON.stringify(updates.metadata));
      }

      paramCount++;
      query += ` WHERE id = $${paramCount}`;
      params.push(id);

      if (client) {
        await client.query(query, params);
      } else {
        await this.pool.query(query, params);
      }

      logger.info('Transaction confirmed', { id, transactionHash: updates.transactionHash });
    } catch (error) {
      logger.error('Error confirming transaction:', error);
      throw new Error('Failed to confirm transaction');
    }
  }

  /**
   * Mark a pending transaction as failed.
   * @param id The transaction ID to mark as failed
   * @param errorMessage The error message to record
   * @param client Optional PoolClient for transaction support
   */
  async failTransaction(
    id: string | number,
    errorMessage: string,
    client?: PoolClient
  ): Promise<void> {
    try {
      const query = `
        UPDATE transactions
        SET status = 'failed',
            updated_at = NOW(),
            metadata = metadata || $1::jsonb
        WHERE id = $2
      `;

      const metadata = JSON.stringify({
        failureReason: errorMessage,
        failedAt: new Date().toISOString()
      });

      if (client) {
        await client.query(query, [metadata, id]);
      } else {
        await this.pool.query(query, [metadata, id]);
      }

      logger.info('Transaction marked as failed', { id, errorMessage });
    } catch (error) {
      logger.error('Error failing transaction:', error);
      throw new Error('Failed to mark transaction as failed');
    }
  }

  /**
   * Get all pending transactions that need reconciliation.
   * Used by admin to find blockchain burns that weren't properly recorded.
   */
  async getPendingReconciliationTransactions(): Promise<TransactionRecord[]> {
    try {
      const query = `
        SELECT * FROM transactions
        WHERE status = 'pending'
        AND type = 'redeem'
        AND metadata->>'requiresReconciliation' = 'true'
        ORDER BY timestamp ASC
      `;

      const result = await this.pool.query(query);
      return result.rows.map(row => this.mapToTransactionRecord(row));
    } catch (error) {
      logger.error('Error getting pending reconciliation transactions:', error);
      throw new Error('Failed to get pending reconciliation transactions');
    }
  }
}